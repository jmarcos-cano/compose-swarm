{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"From Compose to Swarm \u00b6 Meet our app \u00b6 Architecture \u00b6 Nada fancy","title":"Home"},{"location":"#from-compose-to-swarm","text":"","title":"From Compose to Swarm"},{"location":"#meet-our-app","text":"","title":"Meet our app"},{"location":"#architecture","text":"Nada fancy","title":"Architecture"},{"location":"awesome-compose/","text":"Awesome-compose \u00b6 A curated list of Docker Compose samples. https://github.com/docker/awesome-compose","title":"Awesome Compose"},{"location":"awesome-compose/#awesome-compose","text":"A curated list of Docker Compose samples. https://github.com/docker/awesome-compose","title":"Awesome-compose"},{"location":"compose-k8/","text":"Compose on Kubernetes \u00b6 https://github.com/docker/compose-on-kubernetes # in docker desktop kubectl api-versions | grep compose Our app \u00b6 docker stack deploy --orchestrator = kubernetes -c docker-compose.simple.yml compose_swarm_k8 kubectl get all -l \"com.docker.stack.namespace=compose_swarm_k8\" From examples \u00b6 # --------- echo \"\"\" version: '3.3' services: db: build: db image: dockersamples/k8s-wordsmith-db words: build: words image: dockersamples/k8s-wordsmith-api deploy: replicas: 5 web: build: web image: dockersamples/k8s-wordsmith-web ports: - \" 33000 :80 \" \"\"\" > compose/compose-k8.yaml docker stack deploy --orchestrator = kubernetes -c compose/compose-k8.yaml hellokube Other installations \u00b6 AKS EKS GKE kind minikube microk8s kompose \u00b6 only version 1,2 or 3 conversion matrix kompose convert -f compose/docker-compose.kompose.yml --stdout","title":"Compose in k8"},{"location":"compose-k8/#compose-on-kubernetes","text":"https://github.com/docker/compose-on-kubernetes # in docker desktop kubectl api-versions | grep compose","title":"Compose on Kubernetes"},{"location":"compose-k8/#our-app","text":"docker stack deploy --orchestrator = kubernetes -c docker-compose.simple.yml compose_swarm_k8 kubectl get all -l \"com.docker.stack.namespace=compose_swarm_k8\"","title":"Our app"},{"location":"compose-k8/#from-examples","text":"# --------- echo \"\"\" version: '3.3' services: db: build: db image: dockersamples/k8s-wordsmith-db words: build: words image: dockersamples/k8s-wordsmith-api deploy: replicas: 5 web: build: web image: dockersamples/k8s-wordsmith-web ports: - \" 33000 :80 \" \"\"\" > compose/compose-k8.yaml docker stack deploy --orchestrator = kubernetes -c compose/compose-k8.yaml hellokube","title":"From examples"},{"location":"compose-k8/#other-installations","text":"AKS EKS GKE kind minikube microk8s","title":"Other installations"},{"location":"compose-k8/#kompose","text":"only version 1,2 or 3 conversion matrix kompose convert -f compose/docker-compose.kompose.yml --stdout","title":"kompose"},{"location":"docker-compose/","text":"Docker Compose \u00b6 to start using this project make sure you follow up the .env.example fill it with your own variables cp .env.example .env Local Development - Hot Reload \u00b6 docker-compose -f docker-compose.yml -f compose/docker-compose-hotreload.yml config docker-compose -f docker-compose.yml -f compose/docker-compose-hotreload.yml up Workflow \u00b6 graph TD; id1>Common Dev Workflow with compose]; %% comment docker-compose.yml+app -- docker-compose build -->DockerImage; DockerImage -- docker-compose push -->DockerHub; Template docker-compose.yml file \u00b6 docker-compose config Build \u00b6 # build and up docker-compose -f docker-compose.yml up --build # only build docker-compose -f docker-compose.yml build # push it docker-compose -f docker-compose.yml push Start \u00b6 docker-compose up Check the default/created network \u00b6 docker network ls docker network inspect $( docker network ls --format \"{{.Name}}\" --filter name = compose ) docker-compose useful commands \u00b6 # running containers docker-compose ps # running processes in containers docker-compose top # logs docker-compose logs","title":"Docker Compose"},{"location":"docker-compose/#docker-compose","text":"to start using this project make sure you follow up the .env.example fill it with your own variables cp .env.example .env","title":"Docker Compose"},{"location":"docker-compose/#local-development-hot-reload","text":"docker-compose -f docker-compose.yml -f compose/docker-compose-hotreload.yml config docker-compose -f docker-compose.yml -f compose/docker-compose-hotreload.yml up","title":"Local Development - Hot Reload"},{"location":"docker-compose/#workflow","text":"graph TD; id1>Common Dev Workflow with compose]; %% comment docker-compose.yml+app -- docker-compose build -->DockerImage; DockerImage -- docker-compose push -->DockerHub;","title":"Workflow"},{"location":"docker-compose/#template-docker-composeyml-file","text":"docker-compose config","title":"Template docker-compose.yml file"},{"location":"docker-compose/#build","text":"# build and up docker-compose -f docker-compose.yml up --build # only build docker-compose -f docker-compose.yml build # push it docker-compose -f docker-compose.yml push","title":"Build"},{"location":"docker-compose/#start","text":"docker-compose up","title":"Start"},{"location":"docker-compose/#check-the-defaultcreated-network","text":"docker network ls docker network inspect $( docker network ls --format \"{{.Name}}\" --filter name = compose )","title":"Check the default/created network"},{"location":"docker-compose/#docker-compose-useful-commands","text":"# running containers docker-compose ps # running processes in containers docker-compose top # logs docker-compose logs","title":"docker-compose useful commands"},{"location":"docker/","text":"Local Environment \u00b6 Just docker run? \u00b6 docker run -d --rm --name -p 7777 :80 web_server nginx open http://localhost:7777 docker run -it --rm --name container1 alpine sh Does not work Fixed docker runs \u00b6 #create a local network, so that containers can see each other docker network create mynetwork # create the backend Redis container and attach it to the network docker run --name redis -d --network mynetwork redis:alpine # create the app container, expose it in a different port docker run -p 5500 :5000 -it --network mynetwork -e \"REDIS_HOST=redis\" mcano/docker:intro # OR if you prefer local environment development supported by Docker docker run -p 5500 :5000 -it --network mynetwork -e \"REDIS_HOST=redis\" -v $( pwd ) :/code mcano/docker:intro sh","title":"Simple Docker"},{"location":"docker/#local-environment","text":"","title":"Local Environment"},{"location":"docker/#just-docker-run","text":"docker run -d --rm --name -p 7777 :80 web_server nginx open http://localhost:7777 docker run -it --rm --name container1 alpine sh Does not work","title":"Just docker run?"},{"location":"docker/#fixed-docker-runs","text":"#create a local network, so that containers can see each other docker network create mynetwork # create the backend Redis container and attach it to the network docker run --name redis -d --network mynetwork redis:alpine # create the app container, expose it in a different port docker run -p 5500 :5000 -it --network mynetwork -e \"REDIS_HOST=redis\" mcano/docker:intro # OR if you prefer local environment development supported by Docker docker run -p 5500 :5000 -it --network mynetwork -e \"REDIS_HOST=redis\" -v $( pwd ) :/code mcano/docker:intro sh","title":"Fixed docker runs"},{"location":"intro-swarm/","text":"Intro Swarm Mode \u00b6 This section will give you the necessary to go full to production with Docker swarm mode. Swarm vs K8 Docker swarm es mejor que kubernetes .... pero ustedes no estan listos para esta conversacion - Just Kidding Features Cluster management integrated with Docker Engine Declarative service model Scaling Desired state reconciliation (The swarm manager node constantly monitors the desired state ) Multi-host networking Service discovery Load balancing Secure by default (intra node) Rolling updates Hyper EASY Setup \u00b6 Local #!/bin/bash # check swarm is enabled docker info | grep -i swarm docker swarm init || echo \"Already in Swarm Mode\" docker node ls PlaywithDocker #!/bin/bash 1 . Go to http://play-with-docker.com sign in with your user:pass ( create account if needed ) . 2 . Click on the wrench and select either \"3 Managers and 2 Workers\" or \"5 managers and no workers\" 3 . Unless instructed run all the commands on the first node. 4 . Make sure to clone the repo in the swarm nodes ( PWD ) git clone https://github.com/jmarcos-cano/compose-to-swarm.git cd compose-to-swarm DigitalOcean #!/bin/bash # Create 3 droplets with private networking enabled. # WHY 3? # install docker export leader = 165 .227.74.229 export manager1 = 165 .227.77.199 export manager2 = 165 .227.65.241 ssh root@ ${ leader } \"docker version || curl -fsSL https://get.docker.com/ | sh \" && \\ ssh root@ ${ manager1 } \"docker version || curl -fsSL https://get.docker.com/ | sh\" && \\ ssh root@ ${ manager2 } \"docker version || curl -fsSL https://get.docker.com/ | sh\" ssh root@ ${ leader } \"sudo curl -L \" https://github.com/docker/compose/releases/download/1.25.5/docker-compose-Linux-x86_64 \" -o /usr/bin/docker-compose && chmod +x /usr/bin/docker-compose\" && \\ ssh root@ ${ manager1 } \"sudo curl -L \" https://github.com/docker/compose/releases/download/1.25.5/docker-compose-Linux-x86_64 \" -o /usr/bin/docker-compose && chmod +x /usr/bin/docker-compose\" && \\ ssh root@ ${ manager2 } \"sudo curl -L \" https://github.com/docker/compose/releases/download/1.25.5/docker-compose-Linux-x86_64 \" -o /usr/bin/docker-compose && chmod +x /usr/bin/docker-compose\" # init swarm in 1 manager #ssh root@${leader} \"docker swarm init --advertise-addr eth1\" # get the manager join-token #ssh root@${leader} \"docker swarm join-token manager\" # Join the other managers ## PLUS! docker -H ssh://root@ ${ leader } node ls","title":"Intro Docker Swarm"},{"location":"intro-swarm/#intro-swarm-mode","text":"This section will give you the necessary to go full to production with Docker swarm mode. Swarm vs K8","title":"Intro Swarm Mode"},{"location":"intro-swarm/#setup","text":"Local #!/bin/bash # check swarm is enabled docker info | grep -i swarm docker swarm init || echo \"Already in Swarm Mode\" docker node ls PlaywithDocker #!/bin/bash 1 . Go to http://play-with-docker.com sign in with your user:pass ( create account if needed ) . 2 . Click on the wrench and select either \"3 Managers and 2 Workers\" or \"5 managers and no workers\" 3 . Unless instructed run all the commands on the first node. 4 . Make sure to clone the repo in the swarm nodes ( PWD ) git clone https://github.com/jmarcos-cano/compose-to-swarm.git cd compose-to-swarm DigitalOcean #!/bin/bash # Create 3 droplets with private networking enabled. # WHY 3? # install docker export leader = 165 .227.74.229 export manager1 = 165 .227.77.199 export manager2 = 165 .227.65.241 ssh root@ ${ leader } \"docker version || curl -fsSL https://get.docker.com/ | sh \" && \\ ssh root@ ${ manager1 } \"docker version || curl -fsSL https://get.docker.com/ | sh\" && \\ ssh root@ ${ manager2 } \"docker version || curl -fsSL https://get.docker.com/ | sh\" ssh root@ ${ leader } \"sudo curl -L \" https://github.com/docker/compose/releases/download/1.25.5/docker-compose-Linux-x86_64 \" -o /usr/bin/docker-compose && chmod +x /usr/bin/docker-compose\" && \\ ssh root@ ${ manager1 } \"sudo curl -L \" https://github.com/docker/compose/releases/download/1.25.5/docker-compose-Linux-x86_64 \" -o /usr/bin/docker-compose && chmod +x /usr/bin/docker-compose\" && \\ ssh root@ ${ manager2 } \"sudo curl -L \" https://github.com/docker/compose/releases/download/1.25.5/docker-compose-Linux-x86_64 \" -o /usr/bin/docker-compose && chmod +x /usr/bin/docker-compose\" # init swarm in 1 manager #ssh root@${leader} \"docker swarm init --advertise-addr eth1\" # get the manager join-token #ssh root@${leader} \"docker swarm join-token manager\" # Join the other managers ## PLUS! docker -H ssh://root@ ${ leader } node ls","title":"Setup"},{"location":"swarm/","text":"Swarm Steps \u00b6 0. git clone \u00b6 git clone https://github.com/jmarcos-cano/compose-to-swarm.git cd compose-to-swarm 1. Enable Visualizer on port 8080 \u00b6 docker service create \\ --name = viz \\ --publish = 8080 :8080/tcp \\ --constraint = node.role == manager \\ --mount = type = bind,src = /var/run/docker.sock,dst = /var/run/docker.sock \\ dockersamples/visualizer # wait until it says \"service converged\" \u26a0\ufe0f go to your visualizer (click in your upper link port 8080) and see how the services are spread. 2. Simple service create \u00b6 # Create a swarm service from a Nginx docker image docker service create --name nginx-ws -p 80 :80 nginx # List the current services docker service ls \u26a0\ufe0f Go to your visualizer (click in your upper link port 8080) and see how the services are spread. Click also on Port 80 (Nginx) - it should say \"Welcome to Nginx\" Scale the service docker service update --replicas 3 nginx-ws Go to your visualizer (click in your upper link port 8080) and see how the services are spread. Checking service logs docker service logs nginx-ws Delete the service docker service rm nginx-ws # check for running services docker service ls 3. Simple Stack deploy \u00b6 # inspect the stack file and try to understand it cat docker-compose.simple.yml # deploy it docker stack deploy -c docker-compose.simple.yml --resolve-image = always --with-registry-auth compose_swarm # list current services docker service ls \u26a0\ufe0f Go to your app (click in your upper link port 500) and see how the app looks like. ! Go to your visualizer (click in your upper link port 8080) and see how the services are spread. Show current status docker stack ps compose_swarm 4. Environment Variables injection \u00b6 \ud83d\udca1 This will give you a small intro to how you can manage configuration per environment (dev,qa,stage,production) # inspect the stack file and try to find the directive \"FOO=${FOO:-BAR}\" cat docker-compose.simple.yml # inject the new value export FOO = \"Development\" # deploy it and see it update automatically docker stack deploy -c docker-compose.simple.yml --resolve-image = always --with-registry-auth compose_swarm docker stack services compose_swarm # PROD docker stack deploy -c < ( docker-compose --env-file .configs/production.env -f docker-compose.simple.yml config ) --resolve-image = always --with-registry-auth compose_swarm_prod \ud83e\udd47 Dare you to put your own Text there, see how sometimes the application becomes unaccessible? 5. Scale web app \u00b6 Want to handle more traffic? Want to be more resilient? Want High Availability? Swarm got you covered docker service scale compose_swarm_web = 4 \u26a0\ufe0f Go to your app (click in your upper link port 500) and see how which task/container responds Go to your visualizer (click in your upper link port 8080) and see how the services are spread. 6. Declarative Deployment Replicas \u00b6 Instead of scaling your service everytime, why don't we declare it? # Inspect the .replicas file and find \"deploy: \" section cat compose/docker-compose.replicas.yml # Deploy new update for the stack DEPLOYMENT_REPLICAS = 7 docker stack deploy -c compose/docker-compose.replicas.yml --resolve-image = always compose_swarm \u26a0\ufe0f Go to your visualizer (click in your upper link port 8080) and see how the services are spread. 7. Rolling Updates \u00b6 Rolling updates let you update your app with zero-downtime. \ud83d\udca1 v1 has been running for 2 weeks now and you are ready to ship your new and hottest feature on v2, with rolling updates you can easily ship v2 let it coexist with v1 until v1 gets fully drain (removed) and v2 gets out. # inspect .rolling file and find the \"update_config:\" section, try to understand it less compose/docker-compose.rolling.yml # Deploy/update this new configuration for your stack docker stack deploy -c < ( docker-compose -f compose/docker-compose.rolling.yml config ) --resolve-image = always compose_swarm # update image docker stack deploy -c < ( IMAGE_NAME = mcano/compose-to-swarm:v2 docker-compose -f compose/docker-compose.rolling.yml config ) --resolve-image = always compose_swarm Lets force update to see the rolling updates \u00b6 Do this how many times you need in order to see it working. # graceful full restart of your app docker service update --force compose_swarm_web Go to your visualizer (click in your upper link port 8080) and see how the services are spread. 8. Host limit resource \u00b6 One can prevent memory starvation or CPU consumption of your app by adding \"resources:\" section # inspect .resources file and find the \"resources:\" section, try to understand it less compose/docker-compose.resources.yml # Deploy/update this new configuration for your stack docker stack deploy -c compose/docker-compose.resources.yml --resolve-image = always compose_swarm 9. Health Check and Self healing \u00b6 Auto restarts and health-check can also be possible by adding \"healthcheck: \" # Run docker ps first to see there's no (healthy) docker ps # inspect .health file and find the \"healthcheck:\" section, try to understand it less compose/docker-compose.health.yml # Deploy/update this new configuration for your stack docker stack deploy -c compose/docker-compose.health.yml --resolve-image = always compose_swarm # after a few seconds run docker ps Do a: docker service ps compose_swarm_web , Identify the placement of a container (identify on which node is running). Jump into that node and run docker ps find the container and its ID (first column), kill it and see how it self heals docker kill <container ID> info Go to your visualizer (click in your upper link port 8080) and see how the services are spread and self healed. Full Production + LB \u00b6 docker stack deploy -c <(docker-compose --env-file .configs/production.env -f docker-compose.yml config ) --resolve-image=always --with-registry-auth compose_swarm_prod open http://138-197-49-123.nip.io/","title":"Docker Swarm"},{"location":"swarm/#swarm-steps","text":"","title":"Swarm Steps"},{"location":"swarm/#0-git-clone","text":"git clone https://github.com/jmarcos-cano/compose-to-swarm.git cd compose-to-swarm","title":"0. git clone"},{"location":"swarm/#1-enable-visualizer-on-port-8080","text":"docker service create \\ --name = viz \\ --publish = 8080 :8080/tcp \\ --constraint = node.role == manager \\ --mount = type = bind,src = /var/run/docker.sock,dst = /var/run/docker.sock \\ dockersamples/visualizer # wait until it says \"service converged\" \u26a0\ufe0f go to your visualizer (click in your upper link port 8080) and see how the services are spread.","title":"1. Enable Visualizer on port 8080"},{"location":"swarm/#2-simple-service-create","text":"# Create a swarm service from a Nginx docker image docker service create --name nginx-ws -p 80 :80 nginx # List the current services docker service ls \u26a0\ufe0f Go to your visualizer (click in your upper link port 8080) and see how the services are spread. Click also on Port 80 (Nginx) - it should say \"Welcome to Nginx\" Scale the service docker service update --replicas 3 nginx-ws Go to your visualizer (click in your upper link port 8080) and see how the services are spread. Checking service logs docker service logs nginx-ws Delete the service docker service rm nginx-ws # check for running services docker service ls","title":"2. Simple service create"},{"location":"swarm/#3-simple-stack-deploy","text":"# inspect the stack file and try to understand it cat docker-compose.simple.yml # deploy it docker stack deploy -c docker-compose.simple.yml --resolve-image = always --with-registry-auth compose_swarm # list current services docker service ls \u26a0\ufe0f Go to your app (click in your upper link port 500) and see how the app looks like. ! Go to your visualizer (click in your upper link port 8080) and see how the services are spread. Show current status docker stack ps compose_swarm","title":"3. Simple Stack deploy"},{"location":"swarm/#4-environment-variables-injection","text":"\ud83d\udca1 This will give you a small intro to how you can manage configuration per environment (dev,qa,stage,production) # inspect the stack file and try to find the directive \"FOO=${FOO:-BAR}\" cat docker-compose.simple.yml # inject the new value export FOO = \"Development\" # deploy it and see it update automatically docker stack deploy -c docker-compose.simple.yml --resolve-image = always --with-registry-auth compose_swarm docker stack services compose_swarm # PROD docker stack deploy -c < ( docker-compose --env-file .configs/production.env -f docker-compose.simple.yml config ) --resolve-image = always --with-registry-auth compose_swarm_prod \ud83e\udd47 Dare you to put your own Text there, see how sometimes the application becomes unaccessible?","title":"4. Environment Variables injection"},{"location":"swarm/#5-scale-web-app","text":"Want to handle more traffic? Want to be more resilient? Want High Availability? Swarm got you covered docker service scale compose_swarm_web = 4 \u26a0\ufe0f Go to your app (click in your upper link port 500) and see how which task/container responds Go to your visualizer (click in your upper link port 8080) and see how the services are spread.","title":"5. Scale web app"},{"location":"swarm/#6-declarative-deployment-replicas","text":"Instead of scaling your service everytime, why don't we declare it? # Inspect the .replicas file and find \"deploy: \" section cat compose/docker-compose.replicas.yml # Deploy new update for the stack DEPLOYMENT_REPLICAS = 7 docker stack deploy -c compose/docker-compose.replicas.yml --resolve-image = always compose_swarm \u26a0\ufe0f Go to your visualizer (click in your upper link port 8080) and see how the services are spread.","title":"6. Declarative Deployment Replicas"},{"location":"swarm/#7-rolling-updates","text":"Rolling updates let you update your app with zero-downtime. \ud83d\udca1 v1 has been running for 2 weeks now and you are ready to ship your new and hottest feature on v2, with rolling updates you can easily ship v2 let it coexist with v1 until v1 gets fully drain (removed) and v2 gets out. # inspect .rolling file and find the \"update_config:\" section, try to understand it less compose/docker-compose.rolling.yml # Deploy/update this new configuration for your stack docker stack deploy -c < ( docker-compose -f compose/docker-compose.rolling.yml config ) --resolve-image = always compose_swarm # update image docker stack deploy -c < ( IMAGE_NAME = mcano/compose-to-swarm:v2 docker-compose -f compose/docker-compose.rolling.yml config ) --resolve-image = always compose_swarm","title":"7. Rolling Updates"},{"location":"swarm/#lets-force-update-to-see-the-rolling-updates","text":"Do this how many times you need in order to see it working. # graceful full restart of your app docker service update --force compose_swarm_web Go to your visualizer (click in your upper link port 8080) and see how the services are spread.","title":"Lets force update to see the rolling updates"},{"location":"swarm/#8-host-limit-resource","text":"One can prevent memory starvation or CPU consumption of your app by adding \"resources:\" section # inspect .resources file and find the \"resources:\" section, try to understand it less compose/docker-compose.resources.yml # Deploy/update this new configuration for your stack docker stack deploy -c compose/docker-compose.resources.yml --resolve-image = always compose_swarm","title":"8. Host limit resource"},{"location":"swarm/#9-health-check-and-self-healing","text":"Auto restarts and health-check can also be possible by adding \"healthcheck: \" # Run docker ps first to see there's no (healthy) docker ps # inspect .health file and find the \"healthcheck:\" section, try to understand it less compose/docker-compose.health.yml # Deploy/update this new configuration for your stack docker stack deploy -c compose/docker-compose.health.yml --resolve-image = always compose_swarm # after a few seconds run docker ps Do a: docker service ps compose_swarm_web , Identify the placement of a container (identify on which node is running). Jump into that node and run docker ps find the container and its ID (first column), kill it and see how it self heals docker kill <container ID> info Go to your visualizer (click in your upper link port 8080) and see how the services are spread and self healed.","title":"9. Health Check and Self healing"},{"location":"swarm/#full-production-lb","text":"docker stack deploy -c <(docker-compose --env-file .configs/production.env -f docker-compose.yml config ) --resolve-image=always --with-registry-auth compose_swarm_prod open http://138-197-49-123.nip.io/","title":"Full Production + LB"}]}